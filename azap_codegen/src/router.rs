// src/router.rs
use std::collections::HashMap;

use crate::DiscoveredRoute;

pub fn generate_router(routes: &[DiscoveredRoute]) -> String {
    let mut code: String = String::new();

    // Header
    code.push_str("// Auto-generated by Azap - DO NOT EDIT\n");
    code.push_str("// This file is generated from src/routes/ at build time\n\n");
    code.push_str("use axum::Router;\n");
    code.push_str("#[allow(unused_imports)]\n");
    code.push_str("use axum::routing::{get, post, put, patch, delete};\n\n");

    // Function signature
    code.push_str("pub fn register_routes() -> Router {\n");
    code.push_str("    Router::new()\n");

    let mut routes_by_base = HashMap::new();

    for route in routes {
        let base_path = extract_base_path(&route.module_path);

        routes_by_base
            .entry(base_path)
            .or_insert_with(Vec::new)
            .push(route);
    }

    let mut sorted_bases: Vec<_> = routes_by_base.keys().collect();
    sorted_bases.sort();

    for base in sorted_bases {
        let routes = &routes_by_base[base];

        code.push_str(&format!("        // Routes for {}\n", base));

        for route in routes {
            let full_path = combine_paths(&base, &route.path);
            let handler_path = format!("crate::{}::{}", &route.module_path, &route.handler);

            code.push_str(&format!(
                "        .route(\"{}\", {}({}))\n",
                full_path, route.method, handler_path
            ));
        }

        code.push_str("\n");
    }

    code.push_str("}\n");

    code
}

/// Extracts the base HTTP path from a Rust module path.
///
/// The function assumes a module structure like:
///
/// ```text
/// routes::<resource>[::<sub_resource>...]::<handler>
/// ```
///
/// Rules:
/// - If there are exactly 2 segments, returns `"/<resource>"`
/// - If there are more than 2 segments, joins the middle segments with `/`
/// - Otherwise, returns `/`
///
/// # Examples
///
/// ```no__run
/// # use crate::extract_base_path;
/// assert_eq!("/users", extract_base_path("routes::users::get"));
/// assert_eq!(
///     "/users/admin",
///     extract_base_path("routes::users::admin::get")
/// );
/// assert_eq!("/auth", extract_base_path("routes::auth"));
/// ```
fn extract_base_path(module_path: &str) -> String {
    let parts: Vec<&str> = module_path.split("::").collect();

    match parts.len() {
        2 => format!("/{}", parts[1]),
        n if n > 2 => format!("/{}", parts[1..parts.len() - 1].join("/")),
        _ => "/".into(),
    }
}

/// Combines a base path with a route path, handling slashes correctly.
///
/// Rules:
/// - If `path` is `/`, the base path is returned unchanged
/// - If `path` starts with `/`, it is appended directly
/// - Otherwise, a `/` is inserted between `base` and `path`
///
/// # Examples
///
/// ```no__run
/// # use crate::combine_paths;
/// assert_eq!(combine_paths("/users", "/"), "/users");
/// assert_eq!(combine_paths("/users", "/:id"), "/users/:id");
/// assert_eq!(combine_paths("/auth", "login"), "/auth/login");
/// ```
fn combine_paths(base: &str, path: &str) -> String {
    match path {
        "/" => base.to_string(),
        p if p.starts_with('/') => format!("{}{}", base, p),
        p => format!("{}/{}", base, p),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_base_route() {
        assert_eq!("/users", extract_base_path("routes::users::get"));
        assert_eq!(
            "/users/admin",
            extract_base_path("routes::users::admin::get")
        );
        assert_eq!("/auth", extract_base_path("routes::auth"))
    }

    #[test]
    fn test_combine_paths() {
        assert_eq!(combine_paths("/users", "/"), "/users");
        assert_eq!(combine_paths("/users", "/:id"), "/users/:id");
        assert_eq!(combine_paths("/auth", "login"), "/auth/login");
    }
}
