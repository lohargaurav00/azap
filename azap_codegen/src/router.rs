// src/router.rs
use std::collections::HashMap;

use crate::{gaurds::parser::GuardType, DiscoveredRoute};

#[derive(Debug, Clone)]
pub(crate) struct Router(pub String);

impl Router {
    pub fn new() -> Self {
        Self(String::new())
    }

    pub fn generate(&mut self, routes: &[DiscoveredRoute]) {
        let code = &mut self.0;

        // Header
        code.push_str("// Auto-generated by Azap - DO NOT EDIT\n");
        code.push_str("// This file is generated from src/routes/ at build time\n\n");
        code.push_str("use azap::Router;\n");
        code.push_str("#[allow(unused_imports)]\n");
        code.push_str("use azap::axum::routing::{get, post, put, patch, delete};\n");
        code.push_str("use azap::axum::middleware;\n\n");

        // Function signature
        code.push_str(
            "pub fn register_routes(state: AppState) -> Router\n\
         {\n",
        );

        // Group routes by their unique middleware combination
        let mut route_groups: HashMap<String, Vec<&DiscoveredRoute>> = HashMap::new();

        for route in routes {
            // Create a unique key based on the route's guards
            let guard_key = route
                .guards
                .iter()
                .map(|g| format!("{}:{}", &g.guard_type, &g.module_path))
                .collect::<Vec<_>>()
                .join("|");

            route_groups.entry(guard_key).or_default().push(route);
        }

        code.push_str("    let mut router = Router::new();\n\n");

        // Generate a separate sub-router for each middleware combination
        for (guard_key, group_routes) in route_groups {
            if group_routes.is_empty() {
                continue;
            }

            code.push_str("    // Group with middleware: ");
            if guard_key.is_empty() {
                code.push_str("none\n");
            } else {
                code.push_str(&format!("{}\n", guard_key.replace('|', ", ")));
            }

            code.push_str("    let group = Router::new()\n");

            // Add all routes in this group
            for route in &group_routes {
                let base_path = extract_base_path(&route.module_path);
                let full_path = combine_paths(&base_path, &route.path);
                let handler_path = format!("crate::{}::{}", route.module_path, route.handler);

                code.push_str(&format!(
                    "        .route(\"{}\", {}({}))\n",
                    full_path, route.method, handler_path
                ));
            }

            // Apply middleware layers for this group
            if !group_routes[0].guards.is_empty() {
                for guard in &group_routes[0].guards {
                    match guard.guard_type {
                    GuardType::FromFn => code.push_str(&format!(
                        "        .layer(middleware::from_fn(crate::{}))\n",
                        guard.module_path
                    )),
                    GuardType::FromFnWithState => code.push_str(&format!(
                        "        .layer(middleware::from_fn_with_state(state.clone(), crate::{}))\n",
                        guard.module_path
                    )),
                    _ => (),
                }
                }
            }

            code.push_str("    ;\n");
            code.push_str("    router = router.merge(group);\n\n");
        }

        code.push_str("    router.with_state(state)\n");
        code.push_str("}\n");
    }
}

impl Default for Router {
    fn default() -> Self {
        Self::new()
    }
}
/// Extracts the base HTTP path from a Rust module path.
///
/// The function assumes a module structure like:
///
/// ```text
/// routes::<resource>[::<sub_resource>...]::<handler>
/// ```
///
/// Rules:
/// - If there are exactly 2 segments, returns `"/<resource>"`
/// - If there are more than 2 segments, joins the middle segments with `/`
/// - Otherwise, returns `/`
///
/// # Examples
///
/// ```no__run
/// # use crate::extract_base_path;
/// assert_eq!("/users", extract_base_path("routes::users::get"));
/// assert_eq!(
///     "/users/admin",
///     extract_base_path("routes::users::admin::get")
/// );
/// assert_eq!("/auth", extract_base_path("routes::auth"));
/// ```
fn extract_base_path(module_path: &str) -> String {
    let parts: Vec<&str> = module_path.split("::").collect();

    match parts.len() {
        2 => format!("/{}", parts[1]),
        n if n > 2 => format!("/{}", parts[1..parts.len() - 1].join("/")),
        _ => "/".into(),
    }
}

/// Combines a base path with a route path, handling slashes correctly.
///
/// Rules:
/// - If `path` is `/`, the base path is returned unchanged
/// - If `path` starts with `/`, it is appended directly
/// - Otherwise, a `/` is inserted between `base` and `path`
///
/// # Examples
///
/// ```no__run
/// # use crate::combine_paths;
/// assert_eq!(combine_paths("/users", "/"), "/users");
/// assert_eq!(combine_paths("/users", "/:id"), "/users/:id");
/// assert_eq!(combine_paths("/auth", "login"), "/auth/login");
/// ```
fn combine_paths(base: &str, path: &str) -> String {
    match path {
        "/" => base.to_string(),
        p if p.starts_with('/') => format!("{}{}", base, p),
        p => format!("{}/{}", base, p),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_base_route() {
        assert_eq!("/users", extract_base_path("routes::users::get"));
        assert_eq!(
            "/users/admin",
            extract_base_path("routes::users::admin::get")
        );
        assert_eq!("/auth", extract_base_path("routes::auth"))
    }

    #[test]
    fn test_combine_paths() {
        assert_eq!(combine_paths("/users", "/"), "/users");
        assert_eq!(combine_paths("/users", "/:id"), "/users/:id");
        assert_eq!(combine_paths("/auth", "login"), "/auth/login");
    }
}
